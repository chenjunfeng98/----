# 学习笔记

## 浅拷贝和赋值的区别
1. 赋值：<br>
赋值其实是该对象在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生变化，其实都是改变存储空间的内容，两个对象是联动的。<br>
2. 浅拷贝：<br>
重新在堆中创建内存，拷贝前后的对象基本数据类型互不影响，但引用数据类型因共享同一个地址，会相互影响。<br>
3. 深拷贝：<br>
从堆内存中开辟一个新的区域存放对象，对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响。<br>


## 数据类型判断和转化
1. 数据类型判断
typeof：可以判断基础数据类型(null除外)，但是引用数据类型除了function外，其他无法判断；<br> 
instanceof：可以准确判断引用数据类型，但是不能判断基础数据类型；<br>
Object.prototype.toString()：返回[Object Xxx(String/Number)]

2. 数据类型转化
Number()：***null/空字符串***返回0；***undefined***返回NaN;
Boolean()：除了undefined、null、false、''、0(+0/-0)、NaN返回false;


## ES6块级作用域与函数声明
1. 允许在块级作用域内声明函数。<br>
2. 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。<br>
3. 同时，函数声明还会提升到所在的块级作用域的头部。<br>

## ES6知识点
### const(不可修改、不可重复声明、不存在变量提升)
const实际上保证的，并不是变量的值不得改动，而是变量指向的那个***内存地址***所保存的数据不得改动。<br>
不可变的只是这个地址，即不能指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

### 变量的解构赋值
1. let [a,b,c] = [1,2,3]<br>
2. 默认值：let [x, y=4] = [2] //x=2.y=4 <br>
3. 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
4. let { foo(属性): baz(变量) } = { foo: 'aaa', bar: 'bbb' };<br>
baz//'aaa'<br>
对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。<br>
PS：对象赋值模式和变量的区别->逗号。<br>


